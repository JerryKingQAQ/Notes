# 操作系统

## 第一章 操作系统引论

### 1.1 操作系统的目标和作用

操作系统的**目标**：**方便性**、**有效性**、**可扩展性**和**开放性**。



操作系统的**作用**：

- OS作为用户与计算机硬件系统之间的接口
- OS作为计算机系统资源的管理者
- OS实现了对计算机资源的抽象



### 1.2 操作系统的发展过程

- **单道批处理系统**
  - 缺点：系统中的资源得不到充分的利用
- **多道批处理系统**：出现IO请求时换程序，一直处于”忙碌“状态
  - 优点：资源利用率高、系统吞吐量大
  - 缺点：**平均周转周期长、无交互能力**
- **分时系统**：为了满足用户对人机交互的需求。具体体现在：人机交互、共享主机
  - 特点：**多路性**、**独立性**、**及时性**、**交互性**
- **实时系统**：实时系统是指系统能**及时响应**外部事件的请求，在规定的时间内完成对该事件的处理
  - 实时任务的类型：周期性实时任务和非周期性实时任务、硬实时任务（HRT，系统必须满足对截止时间的要求）和软实时任务（SRT）
  - 特点：**多路性**、**独立性**、**及时性**、**交互性**、**可靠性**（比分时多了这个）



### 1.3 操作系统的基本特征

具有的4个基本特征：**并发**、**共享**、**虚拟**和**异步**。**（重点）**

**并发和共享**是多用户（多任务）OS的两个**最基本的特征**

#### 1. 并发

并发和并行的区别：

- **并行性**：是指两个或多个事件在**同一时刻**发生
- **并发性**：是指两个或多个事件在**同一时间间隔内**发生

**进程**：是指在系统中能**独立运行并作为资源分配的基本单位**，它是由一组机器指令、数据和堆栈等组成 的，是一个能独立运行的活动实体

#### 2. 共享

资源共享或资源复用：是指在系统中的**资源**可供内存中多个**并发执行**的**进程共同使用**

由于资源属性的不同，进程对资源复用的方式也不同。

两种资源共享的主要方式：

- 互斥共享方式（互斥共享打印机）
- 同时共享方式（同时共享磁盘设备）

#### 3. 虚拟

虚拟：在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”。

两种虚拟方式：

- 时分复用技术（多道程序技术）
  - 应用：CPU、虚拟处理机、虚拟设备
  - 利用处理机的空闲时间
- 空分复用技术
  - 应用：电信业
  - 利用存储器的空闲空间

#### 4. 异步

由于资源等因素的限制，使进程的执行通常都不可能“一气呵成”，而是以“走走停停”的方式运行。**进程**是以**人们不可预知的速度**向前推进的，此即程序的异步性。



### 1.4 操作系统的运行环境

主要有**硬件**和**系统内核**组成

##### 操作系统的内核

大多数操作系统内核都有以下两类功能：

- 支撑功能：实现众多模块所需要的基本功能
  - 三个基本功能：**中断处理**、**时钟管理**、**原语操作**
- 资源管理功能：对系统资源的管理
  - 进程管理、存储器管理、设备管理



### 1.5 操作系统的主要功能 （简答题）

#### 1. 处理机管理功能

主要功能：创建和撤销进程，对进程的运行进行协调，实现进程之间的信息的交换，以及按照一定的算法把处理机分配给进程**（管理进程）**

总结而言以下四点：

- **进程控制**：创建和撤销进程
- **进程同步**：对进程的运行进行协调
- **进程通信**：实现进程之间的信息的交换
- **调度**：分为作业调度和进程调度

#### 2. 存储器管理功能

主要任务：为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存

主要为以下四点功能：

- **内存分配与回收**：分为静态分配方式和动态分配方式。分配内存空间，提高存储器利用率。
- **内存保护**：确保每道用户进程只在自己的内存空间内运行，绝不可用户程序访问OS的程序和数据
- **地址映射**：将逻辑地址变换为物理地址
- **内存扩充**：利用虚拟存储技术，从逻辑上扩大内存容量

#### 3. 设备管理功能

主要任务：完成用户进程提出的I/O请求，为用户分配I/O设备。

主要有以下三点功能：

- **缓冲管理**：在IO设备和CPU之间引入缓冲，缓解速度不匹配的问题
- **设备分配**：根据IO请求与系统现有资源情况，按照某种策略分配设备
- **设备处理**：又称为设备驱动程序，完成CPU和设备控制器之间的通信

#### 4. 文件管理功能

主要任务：对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性

主要有以下三个功能：

- **文件储存空间管理**：为每个文件分配必要的外存空间、提高外存的利用率、记录文件存储空间的使用情况....
- **目录管理**：为每个文件建立一个目录项，包括文件名、文件位置等信息，方便用户按名查找
- **文件的读/写管理和保护**：读写管理：根据用户的请求对外村进行读写操作；文件保护：防止系统中的文件被非法窃取和破坏

#### 5. 接口管理功能

分为：

- **用户接口**：为了便于用户直接或间接地控制自己的作业
  - 分为：联机用户接口、脱机用户接口、图形用户接口
- **程序接口**：用户程序在执行中访问系统资源而设置的，是用户查询取得OS服务的唯一途径



### 1.6 操作系统的结构

#### 传统操作系统结构

- **模块化结构OS**
  - 该技术基于**“分解”**和**“模块化”**的原则来控制大型软件的复杂度。为使OS具有较清晰的结构，OS不再是由众多的过程直接构成的，而是按其功能精心地划分为若干个具有**一定独立性和大小的模块**
  - 优点：维护性好、适应性强、加速了OS的开发过程
  - 缺点：对接口的规定很难满足实际要求、各种决定的无序性
- **分层式结构OS**
  - 为了将模块-接口法中“决定顺序”的**无序性变为有序性**，引入了有序分层法，分层法的设计任务是，在目标系统An和裸机系统(又称宿主系统)A0之间，铺设若干个层次的软件A1、A2、A3、…、An-1，使An通过An-1、An-2、…、A2、A1层，最终能在A0上运行。在操作系统中，常采用自底向上法来铺设这些中间层。
  - 优点：易维护系统的正确性、可保证系统的易维护性和可扩充性
  - 缺点：系统效率低



#### 微内核OS结构

微内核操作系统的优点：

- 提高了OS的**可扩展性**
- 增强了OS的**可靠性**
- 增强了OS的**可移植性**
- 适用于**分布式**系统



<div STYLE="page-break-after: always;"></div>

## 第二章 进程的描述与控制

### 2.1 前驱图和程序执行

前驱图是一个**有向无环图**，用于描述进程之间执行的先后顺序。

前驱图中不允许有循环



#### 程序顺序执行

特征：**顺序性**、**封闭性**和**可再现性**



#### 程序并发执行

程序并发执行时的特征：**（重点）**

- **间断性**
- **失去封闭性**
- **不可再现性**

例子：两个循环程序A和B，它们共享一个变量N。A：N=N+1；B：Print(N)， N=0; 

A和B以不同的速度运 行，则可能出现下述三种情况：

1. N=N+1在print(N)和N=0之前，N的值为n+1，n+1，0
2. N=N+1在print(N)和N=0之间，N的值为n，n+1，0
3. N=N+1在print(N)和N=0之后，N的值为n，0，1



### 2.2 进程的描述 （重点）

#### 进程的定义和特征

定义：在操作系统中必须为之配置一个专门的数据结构，称为**进程控制块（process control block, PCB）**。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。

由**程序段**、**相关的数据段**和**PCB**三部分便构成了**进程实体**（又称进程映像）。

**进程=数据段+程序段+PCB**

最后可以定义为：进程是程序的执行过程中，是系统进行资源分配和调度的一个独立单位



进程的特征：

- **动态性**：进程的实质是程序的执行过程，因此动态性是进程最基本的特征
- **并发性**：是指多个进程共存于内存中，且能在一段时间内同时执行
- **独立性**：是指进程是一个能独立运行、独立获取资源、独立接受调度的基本单位
- **异步性**：是指进程是按异步方式运行的，即按各自独立、不可预知的速度向前推进的



#### 试比较进程与程序的异同（必考）

进程和程序是紧密相关而又完全不同的两个概念。

- 每个**进程实体**中包含了**程序段**和**数据段**这两个部分，**因此说进程与程序是紧密相关的**。但从结构上看，进程实体中除了程序段和数据段外，还必须包含一个数据结构，即**进程控制块**PCB。
- **进程是程序的一次执行过程**，因此是**动态的**；动态性还表现在进程由创建而产生、由调度而执行、由撤消而消亡，即它具有一定的生命期。而程序则只是**一组指令的有序集合**，并可永久地存放在某种介质上，其本身不具有运动的含义，因此是**静态的**。
- 多个进程实体可同时存放在内存中**并发地执行**，这正是引入进程的目的。而程序(在没为它创建进程时)的并发执行具有不可再现性，因此**程序不能正确地并发执行**。
- 进程是一个能够独立运行、独立分配资源和独立接受调度的基本单位。而程序(在没为它创建进程时)因其不具有 PCB，故是**不可能在多道程序环境下独立运行的**。
- **进程和程序不是一一对应的关系**。一个程序多次运行产生多个不同的进程。一个程序的一次运行也可以产生多个进程，一个进程在不同时期也可以执行不同的程序



#### 进程的基本状态及转换

进程的三种基本状态：

- **就绪状态**：指进程已分配到除CPU外的所有资源，只要再获得CPU即可立即执行的状态
- **执行状态**：指进程获得CPU后正在执行的状态
- **阻塞状态**：正在执行的进程由于某事件（如IO请求）而暂时无法继续执行

三种状态的转换

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231227151314709.png" alt="image-20231227151314709" style="zoom:60%;" />

就绪不能直接到阻塞，阻塞不能直接到执行。**只有就绪和执行可以相互转换**。



#### 进程管理中的数据结构

在计算机系统中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，我们称之为资源信息表或进程信息表。

OS管理的这些数据结构一般分为以下四类：**内存表、设备表、文件表和用于进程管理的进程表（PCB）**，通常进程表又被称为进程控制块PCB

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231227151905735.png" alt="image-20231227151905735" style="zoom:60%;" />

PCB的作用：使一个在多道程序环境下不能独立运行的程序（含数据），**成为一个能独立运行的基本单位**，即一个能与其他进程并发执行的进程。

**PCB中的信息**：（重点）

- **进程标识符**：唯一标识一个进程。分为外部标识符（面向用户）和内部标识符（面向系统）
- **处理机状态**：保存正在处理的信息在寄存器中的断点，以便重新调度后使用
- **进程调度信息**：进程的状态和有关进程调度的信息
- **进程控制信息**：用于进程控制所必须的信息



PCB组织方式：

- 线性方式、链接方式、索引方式



### 进程控制

进程图一般是树形的

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231227153125294.png" alt="image-20231227153125294" style="zoom:67%;" />

#### 引起创建进程的事件

为使**程序**之间能并发运行，**应先为它们分别创建进程**。导致一个进程去创建另一个进程的典型事件有四类：

- 用户登录
- 作业调度
- 提供服务
- 应用请求

只有进程才能在系统中运行



#### 进程的阻塞与唤醒

引起进程阻塞和唤醒的事件：

- 向系统请求共享资源失败
- 等待某种操作的完成
- 新数据尚未到达
- 等待新任务的到达



### 2.5 线程的概念

**线程**是**比进程更小**的基本单位

如果说，在OS中引入**进程的目的**是为了使**多个程序能并发执行**，以**提高资源利用率**和**系统吞吐量**。那么，在操作系统中再引入**线程**，则是为了**减少**程序在**并发执行时**所付出的**时空开销**，使OS具有**更好的并发性**

**线程——作为调度和分派的基本单位，但不是拥有资源的基本单位**

进程可以拥有资源，但线程不拥有资源



#### 线程和进程的比较（重点）

由于线程具有许多传统进程所具有的特征，所以又称为轻型进程或进程元。相应的传统进程称为重型进程。

从调度的几个方面进行比较：

- **调度的基本单位**：在引入线程的OS中，**线程是调度和分派的基本单位**，是能独立运行的基本单位。
- **并发性**：在引入线程的OS中，不仅进程之间可以并发执行，一个进程中的**多个线程之间也能并发执行**
- **拥有资源**：进程可以拥有资源，可以认为是系统中拥有资源的一个基本单位。而**线程几乎不拥有资源**，其仅有确保自生能够独立运行的一点资源
- **独立性**：同一进程的不同线程独立性相较于不同进程之间的独立性**低得多**
- **系统开销**：线程的创建、切换、回收等消耗的系统资源要远**低于**进程
- **支持多处理机系统**：一个进程中的多个线程能分配到多个处理机上**并行运行**



#### 线程状态和线程控制块

线程也是三个运行状态：执行状态、就绪状态、阻塞状态

线程控制块（Thread Control Block，TCB）和PCB类似，通常有：

- 线程标识符
- 一组寄存器
- 线程执行状态
- 优先级...



#### 多线程OS中进程的属性

一个进程通常包含多个线程，并为它们提供资源。

- 进程是一个可拥有资源的基本单位
- 多个线程可以并发执行
- 进程已不是可执行的实体：线程作为独立运行（或称为调度）的基本单位



<div STYLE="page-break-after: always;"></div>

## 第三章 处理机调度与死锁

### 3.1 处理机调度概述

处理机调度**层次**：

- **高级调度（作业调度）**：主要用于多道批处理系统中，决定外存上处于后备队列中的哪几个作业调入内存（周期较长）
- **中级调度（内存调度）**：将暂不运行的**进程**，调至外存等待；将处于外存上的急需运行的进程，调入内存运行，即“对换” 功能
- **低级调度（进程调度）**：根据某种调度算法，决定就绪队列中的哪个进程应获得处理机；应用在于多道批处理、分时和实时OS （运行频率最高）



#### 作业和作业调度

作业是一个比进程更为广泛的概念，它不仅包含了通常的程序和数据，而且配有一份作业说明书，系统根据该说明书对程序的允许进行控制。

**作业控制块 JCB** 

为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，**它是作业在系统中存在的标志**，其中保存了系统对作业进行管理和调度所需的全部信息



#### 进程调度

进程调度的任务主要有三类（重要）：

- 保护CPU现场信息
- 按照某种算法选取进程
- 把CPU分配给进程



进程调度方式：

- **非抢占式调度方式**：一旦把处理机分配给某进程，就会一直让它运行下去，而绝不会因为时钟中断或其他原因去抢占该进程的处理机
- **抢占式调度方式**：允许调度程序根据某种原则去暂停某个正在执行的进程，并将处理机分配给另一进程



#### 处理机调度算法的目标

处理机调度算法的共同目标：

- **资源利用率**：
  $$
  CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}
  $$

- **公平性**：各进程都获得合理的CPU时间

- **平衡性**：使CPU和各种IO设备都能经常处于忙碌状态

- **策略强制执行**：对于所指定的策略（包括安全策略），只要有需要就要予以准确的执行



批处理系统中处理机调度算法的目标：

- 平均周转时间短：周转时间是指作业被**交给系统开始到作业完成为止**的这段时间间隔，平均周转时间表示为：
  $$
  T=\frac{1}{n}\sum_{i=1}^n{T_i}
  $$
  平均带权周转时间表示为：
  $$
  T_w=\frac{1}{n}\sum_{i=1}^n{\frac{T_i}{T_s}}
  $$
  其中`Ti`是**周转时间**，`Ts`是系统为进程提供的**服务时间**

- 系统吞吐量高

- 处理机利用率高



### 3.2 调度算法（重要）

**重要的时间概念：（重要）**
$$
等待时间=运行时刻 - 到达时刻
$$

$$
周转时间=完成时刻 - 到达时刻
$$

平均等待/周转时间即为它们除以作业数

#### 1. 先来先服务算法 FCFS

当在作业调度中采用该算法时，系统将按照**作业到达的先后次序**来进行调度，或者说它是优先考虑在系统中**等待时间最长**的作业



#### 2. 短作业优先算法 SJF

SJF算法可以分别用于作业调度和进程调度。

SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所**要求的运行时间**来衡量的

缺点：

- 只能估算进程的运行时间（估值不准确）
- 对长作业不利，无人机交互
- 完全未考虑作业的紧迫程度



#### 3. 优先级调度算法 PSA

基于作业的紧迫程度，**由外部赋予作业相应的优先级**，调度算法是根据该优先级进行调度的



#### 4. 高相应比优先调度算法 HRRN

高响应比优先调度算法既考虑了**作业的等待时间**，又考虑**作业运行时间**的调度算法

动态优先级的变化规律可描述为：
$$
优先级=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}
$$


#### 5. 轮转调度算法 RR

在分时系统中，最简单也是较常用的是**基于时间片的轮转调度算法**。该算法采取了非常公平的处理机分配方式，即让就绪队列上的每个进程每次仅运行一个时间片。

**基本原理：**

在轮转(RR)法中，系统将所有的就绪进程按FCFS策略排成一个就绪队列。系统可设置**每隔一定时间(如30 ms)便产生一次中断**，去激活进程调度程序进行调度，把CPU分配给队首进程，并令其执行一个时间片。

**切换时机：**

- **若一个时间片尚未用完**，**正在运行的进程便已经完成**，就立即激活调度程序，将它从就绪队列中 删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片
- **在一个时间片用完时**，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往**就绪队列的末尾**



#### 6. 多级反馈队列调度算法

多级反馈队列调度算法不必事先知道各种进程所需的执行时间，还可以较好地满足各种类型进程的需要，**因而它是目前公认的一种比较好的进程调度算法**。

调度机制：

- 设置多个就绪队列
  - 每个队列赋予不同的优先级
  - **优先级越高的队列中，时间片越小**
- 每个队列都采用FCFS算法
  - 新进程进入内存后，**放入第一个队列末尾**，按FCFS策略等待调度
  - 如果时间片用完未完成，调度程序将其转入**第二个队列的末尾**等待调度
- 按队列优先级调度
  - **仅当第一队列空闲时**，才调度第二队列中进程运行
  - 当处理机在第i队列为某进程服务时，有新进程进入**任一优先级较高的队列**，则需把**正在运行的进程放回第i队列的末尾**，并把处理机分配给高优先级进程

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231230210602989.png" alt="image-20231230210602989" style="zoom:50%;" />



### 3.4 实时调度

在实时系统中，存在着HRT任务和SRT任务，它们联系着一个**截止时间**

#### 实时调度的基本条件

主要有四点：

- **提供必要的信息**

  - 就绪时间、开始和截止时间、处理时间、资源要求

- **系统处理能力强**

  - N个处理器
    $$
    \sum_{i=1}^n\frac{处理时间_i}{周期时间_i}\le N
    $$

- **采用抢占式调度机制**

  - 基于**时钟中断**的抢占式优先级调度算法：某实时任务到达后，如果优先级高于当前任务的优先级，此时**并不立即抢占当前任务的处理机**，而是**等时钟中断后**才会调配到高优先级任务
  - **立即抢占**的优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行转向新进程

- **采用快速切换机制**

  - 对中断的快速响应能力、快速的任务分配能力

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231230213407859.png" alt="image-20231230213407859" style="zoom:60%;" />



#### 1. 最早截止时间优先算法 EDF

根据**任务的截止时间**确定任务的优先级，任务的**截止时间愈早，其优先级愈高**，具有最早截止时间的任务排在队列的队首

分为非抢占式和抢占式

![image-20231230214358397](C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231230214358397.png)

这是一种根据截止时间**动态调整**的算法



#### 2. 最低松弛度优先算法 LLF

**松弛度越低，优先级越高**

可以任务还可以玩多久

**松弛度计算公式：**（重要）
$$
松弛度=截止时刻 - 需运行的时间 - 当前时刻
$$


### 3.5 死锁概述

死锁的定义：

在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源

**产生死锁的必要条件：（同时具备，重要）**

- **互斥条件**
  - 进程所分配到的资源进行**排他性使用**，即在一段时间内，某资源只能被一个进程占用
- **请求和保持条件**
  - 进程已经占有至少一个资源，但又提出新的资源请求，而该资源被其他进程占有，**则此时请求进程被阻塞，同时对其自己已占有的资源保持不放**
- **不可抢占条件**
  - 进程已获得的资源在**未使用完之前不能被抢占**，只能在进程使用完时由**自己释放**
- **循环等待条件**
  - 发生死锁时，必然存在一个”进程——资源“循环链，**互相等待被占用资源**



### 3.6 死锁预防

有三种方式：

- **破坏”请求和保持“条件**
  - 第一种协议：所有进程开始运行前，**必须一次性申请其在运行过程中所需的全部资源**
  - 第二种协议：第一种的改进，允许一个进程获得初始资源后就允许，然后再释放已分配给自己的、且已用毕的全部资源，最后再申请资源
- **破坏“不可抢占”条件**
  - 当一个已经保持了某些不可抢占资源的进程提出新的资源请求而**不能得到满足**时，**必须释放已经保持的所有资源**，待以后需要时再重新申请
  - 这意味着进程已占有的资源会被暂时地释放，或者说是被抢占了，从而破坏了“不可抢占”条件。
- **破坏“循环等待”条件**
  - **规定每个进程必须按序号递增的顺序请求资源**
  - 一个能保证“循环等待”条件不成立的方法是，对系统所有资源类型进行线性排序，并赋予不同的序号
  - 当且仅当F(Rj) > F(Ri)时，进程才可以请求Rj的单元



### 3.7 死锁避免

避免死锁的方法中，系统分为安全状态和不安全状态。当系统处于安全状态时可避免发生死锁；而当系统处于**不安全状态**时，则**可能**进入死锁状态



#### 银行家算法避免死锁（重要）

几个重要的概念：

- Max：所需要的全部资源数量
- Allocation：已分配的资源数量
- Need：目前所需要的资源数量
- Available：目前剩余的资源数量
- Work：当前可使用的资源数量
- Work+Allocation：进程释放资源后的可用资源数量
- Finsh：是否完成分配

![image-20231230231231981](C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231230231231981.png)

![image-20231230231420953](C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231230231420953.png)

方法：先找到一个Avaiable满足Need的进程。然后第一行Work开始写，然后每一行Work是上一行的Work+Allocation。



### 3.8 死锁的检测与解除

#### 死锁的检测

资源分配图：

**从资源到进程的线是分配，从进程到资源的线是请求**

如果节点P能获得所有资源，则对资源分配图进行简化，消除P的请求边和分配边。

证明状态S为死锁状态的充分条件：当且仅当S状态的资源分配图是不可完全简化的。**（死锁定理，非充要条件）**

基本事实：（重要）

- 如果图没有环，那么不会有死锁
- 如果图有环，那么
  - 如果**每一种资源类型只有一个实例（即只有一个资源时）**，那么**死锁发生**
  - 如果一种资源类型有**多个实例**，那么**可能死锁**



#### 死锁的解除

分为两类：

- **终止死锁进程的方法**
  - 终止所有死锁进程、逐个终止死锁进程
- **付出代价最小的死锁解除算法**
  - 先终止一个死锁进程P1，状态S变为U1，对死锁进程P2 P3等重复上述过程，得到状态D2 D3...，同时记录它们的代价C1 C2 C3。选择最小的代价的死锁进程终结方向，然后再重复上述步骤，直至死锁状态解除。



<div STYLE="page-break-after: always;"></div>

## 第四章 进程同步

### 4.1 进程同步的基本概念

两种形式的制约关系：

- 直接相互制约关系（同步关系）
- 间接相互制约关系（互斥关系）





临界区问题应遵守的4条准则：

- **空闲让进**：空闲状态时允许一个请求的进程进入临界区
- **忙则等待**：当有进程在临界区时，其他申请的进程需要等待
- **有限等待**：对于要求访问临界资源的进程，应保证其在有限的时间内能进入自己的临界区，避免陷入“死等”
- **让权等待（**非必须）：当进程不能进入自己的临界区时，应立即释放处理机，以免陷入“忙等”状态



### 4.6 经典的进程同步问题

#### 1. 同步互斥算法

有 4 个进程 P1、P2、P3、P4。要求 P1 必须在 P2、P3 开始前完成，P2、P3 必须在 P4 开始前完成，且 P2 和 P3 不能并发执行。试写出这 4 个进程的同步互斥算法

```c++
Semaphore mutex = 1; // 互斥信号量 用于P2和P3不能并发执行
Semaphore s1, s2, s3, s4 = 0; // 同步信号量
P1(){
 执行代码
 V(s1); // signal 释放
 V(S2);
}

P2(){
 P(s1); // wait 获取
 P(mutex); // 互斥访问
 执行代码
 V(mutex);
 V(s3);
}
...
```



k'k'kkk'k'k'k

#### 2. 生产者-消费者问题

**关键：**

- 使用**mutex**对缓冲区进行**互斥访问**
- 使用信号量**empty**和**full**分别表示缓冲池中**空缓冲区**和**满缓冲区**的**数量**
- 要**先P(empty)再P(mutex)**，否则可能产生死锁

有三个进程PA、PB和PC协作解决文件打印问题。PA将文件记录从磁盘读入内存的缓冲区1，每执行一次读一个记录;PB 将缓冲区1的内容复制到缓冲区2中，每执行一次复制一个记录PC 将缓冲区2的内容打印出来，每执行一次打印一个记录。

```c++
semaphore empty1=1, full1=0, empty2=1, full2=0;
PA(){
	while(1){
		从磁盘中读取一个记录;
		P(empty1);
		将记录放到缓冲区1;
		V(full1);
	}
}
PB(){
    while(1){
        P(full1);
        从缓冲区1中取出一个记录;
        V(empty1);
        P(empty2);
        将记录复制到缓冲区2;
        V(full2);
    }
}
...
```



设有两个生产者进程A、B和一个销售者进程C，他们共享一个无限大的仓库，生产者每次循环生产一个产品，然后入库供销售者销售；**销售者每次循环从仓库中取出一个产品进行销售**。如果不允许同时入库，也不允许边入库边出库；而且要求生产A产品和B产品的件数满足以下关系:`-n ≤ A的件数 - B的件数 ≤ m`，其中n、m是正整数，但对仓库中A产品和B产品的件数无上述要求。请用信号量机制写出A、B、C三个进程的工作流程。

`-n ≤ A的件数 - B的件数 ≤ m`转化成**SAB表示允许A生产的产品数量**，**SBA表示允许B生产的数量**；初值为0的信号量S，对应仓库中的产品量

```c++
semaphore SAB=m, SBA=n, S=0, mutex=1;
PA(){
    while(1){
        P(SAB);
        生产A;
        V(SBA); // A生产了一个，此时允许B多生产一个
        P(mutex);
        将A放入仓库;
        V(mutex);
        V(S); // 仓库数量加一
    }
}
PA(){
    while(1){
        P(SBA);
        生产B;
        V(SAB); // B生产了一个，此时允许A多生产一个
        P(mutex);
        将B放入仓库;
        V(mutex);
        V(S); // 仓库数量加一
    }
}
PC(){
    while(1){
        P(S);
        P(mutex);
        拿走A或B一个产品;
        V(mutex);
        销售一个产品;
    }
}
```



### 3. 哲学家进餐问题

有 n（n≤3）位哲学家围坐在一张圆桌边，每位哲学家交替地就餐和思考。在圆桌中 心有 m（m≥1）个碗，每两位哲学家之间有 1 根筷子。每位哲学家必须取到一个碗和两侧 的筷子之后，才能就餐，进餐完毕，将碗和筷子放回原位，继续思考。为使尽可能多的哲学 家同时就餐，且防止出现死锁现象

使用第三种方式：

规定奇数号哲学家先拿左边筷子，再拿右边的筷子；偶数号哲学家则相反

```c++
semaphore chopsick[n]=1; // 筷子数量
semaphore bowl=m;

Pi(){
    while(1){
        if(i%2==0){ // 偶数
            P(chopstick[(i+1)%n]); // 右边筷子
            P(chopstick[i]); // 左边筷子
            P(bowl);
            吃饭;
            V(chop);
            V(chopstick[(i+1)%n]);
            V(chopstick[i]);
            V(bowl);
        }
        else{ // 计数
            P(chopstick[(i)%n]); // 左边筷子
            P(chopstick[i+1]); // 右边筷子
            P(bowl);
            吃饭;
            V(chop);
            V(chopstick[(i)%n]);
            V(chopstick[i+1]);
            V(bowl);
        }
    }
}
```



### 4. 读者-写者问题

关键：

- 如果有读者在访问对象，则其他读者可以进行读操作
- 如果有读者在访问对象，则写者等待
- 如果有写者在访问对象，则所有读者等待，其他写者也要等待

```c++
semaphore rmutex=1; // 用于保护readcount
semaphore wmutex=1; // 写者之间、写者和所有读者之间的互斥锁
int readcount=0; // 读者数量

void reader(){
    while(1){
        P(rmutex); 
        if(readcount==0) // 如果没有读者此时
            P(wmutex); // 说明可能有写者 查询写者是否正在写
        readcount++; // 没有的话，就加一个读者
        V(rmutex);
        
        读操作;
        
        P(rmutex); 
        readcount--; // 一个读者读完
        if(readcount==0) // 如果读者数量为0
            V(wmutex); // 此时释放写者锁
        V(rmutex); // 释放保护readcount的锁
    }
}

void writer(){
    while(1){
        P(wmutex);
        写操作;
        V(wmutex);
    }
}
```









<div STYLE="page-break-after: always;"></div>

## 第五章 存储器管理

### 5.1 存储器的层次结构

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231231155316381.png" alt="image-20231231155316381" style="zoom:50%;" />

### 5.2 程序的装入和链接

两类地址：

- **物理地址**（绝对地址）
  - 内存单元看到的地址
- **逻辑地址**（虚拟地址、相对地址）
  - 由CPU产生的地址，即程序编译后使用的相对于0字节的地址

内存保护：

- 保护OS不被用户访问
- 判断“**基地址 ≤ 物理地址＜(基地址+界限地址)**”是否成立。



程序的装入内存的步骤：**编译-链接-装入**

分为三类装入方式：

- **绝对装入方式**
  - 编译时产生的地址使用绝对地址
- **可重定位装入方式**
  - 编译后的目标模块使用相对地址
  - **在装入时**，完成**重定位**（静态重定位）
- 动态运行时装入方式
  - 编译后的目标模块使用相对地址
  - **在运行时**，完成**重定位**（动态重定位）



### 5.3 对换和覆盖

常见的内存“扩充”技术有对换、覆盖、紧凑和虚拟存储器

#### 对换

在多道程序环境下：一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；另一方面，却又有着许多**作业在外存上等待**，因无内存而不能进入内存运行的情况。浪费资源，降低系统吞吐量。

**对换的概念**：把内存中暂时**不能运行的进程**或者暂时不用的程序和数据，**调出到外存上**，以便腾出足够的内存空间，再把已**具备运行条件的进程**或进程所需的程序或数据，**调入内存**。



#### 覆盖

解决的问题：为了能让进程的大小比它所分配的内存空间大  **（程序大小超过物理内存总和）**

思想：程序执行时

- 只在内存中**保留**那些在**任何时间都需要**的**指令和数据**

- 程序的**不同部分**在内存中**相互替换**



### 5.4 连续分配存储管理方式

连续分配方式是最早出现的一种存储器分配方式，**该方式为一个用户程序分配一个连续的内存空间**，**即程序中的代码或数据的逻辑地址相邻**。

分为四类：单一连续分配、固定分区分配、动态分区分配、动态可重定位分区分配算法

#### 1. 单一连续分配

将内存分为系统区和用户区两部分，系统区仅供OS使用，放在内存的低址部分。**而用户区内存中，仅装有一道用户程序**，即整个内存的用户区由该程序独占。



#### 2. 固定分区分配

将整个用户空间划分为若干个**固定大小的区域**，在**每个分区中只装入一道作业**。

划分分区的方法：

- 分区大小相等（所有的内存分区大小相等）
- 分区大小不相等



内存分配：为了便于内存分配，通常**将分区按其大小进行排队**，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102213623660.png" alt="image-20240102213623660" style="zoom: 45%;" />



#### 3. 动态分区分配（重要）

动态分区分配又可称为可变分区分配，它是根据进程的实际需要，**动态地为之分配内存空间**

常用的数据结构形式：

- **空闲分区表**
  - <img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102213853248.png" alt="image-20240102213853248" style="zoom:40%;" />
- **空闲分区链**
  - <img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102213924591.png" alt="image-20240102213924591" style="zoom:50%;" />

##### 动态分区分配算法（非常重要）

基于**顺序搜索**的动态分区分配算法**（顺序分配法）**：

- **首次适应（FF，First Fit）算法**
  - FF算法要求空闲分区链以地址递增的次序链接
  - 在分配内存时，**从链首开始顺序查找**，直至找到一个**大小能满足要求的空闲分区**为止
  - 缺点：低地址部分留下许多小碎片
- **循环首次适应（NF，Next Fit）算法**
  - 为避免低址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销 **FF的改进**
  - 不再是每次都从链首开始查找，而是**从上次找到的空闲分区的下一个空闲分区开始查找**
  - 优点：空闲分区分布更均匀，减少了查找的开销
  - 缺点：缺乏大的空闲分区
- **最佳适应（BF，Best Fit）算法**
  - 总是把**能满足要求、又是最小的**空闲分区分配给作业
  - 该算法要求将所有的空闲分区按其**容量以从小到大的顺序形成一空闲分区链**
  - 缺点：用最小空间满足要求，但留下许多难以利用的小碎片
- **最坏适应（WF，Worst Fit）算法**
  - 与最佳适应算法相反
  - **总是挑选一个最大的空闲区**，从中**分割**一部分存储空间给作业使用，分割后空闲块仍为较大空块
  - 优点：产生的空闲区不至于太小，产生碎片的概率最小



基于**索引搜索**的动态分区分配算法**（索引分配法）**：（适合较大的系统）

- **快速适应（Quick Fit）算法**
  - 第一步：根据进程的长度，在索引表中找到能容纳它的最小空闲分区链表
  - 第二步：从链表中取下第一块进行分配
  - 优点：查找效率高
  - 缺点：为了合并有效分区，分区归还内存时的算法较为复杂
- **伙伴系统**
  - 无论已分配分区或空闲分区，**其大小均为2的k次幂(k为整数，l≤k≤m)**
  - 首先在**2^i**的空闲分区链表中查找，如能找到则分配给进程；否则说明已经耗尽
  - 若存在一个大小为**2^(i+1)**的空闲分区，则将其分为两个相同大小的分区，称为一对“伙伴”：**其中一个分区用于分配**，**而另一个分区加入大小为2^i的空闲分区链表中**
- **哈希算法**
  - 建立哈希函数，构造一张以空闲分区大小为关键字的哈希表
  - 该表的每个表项均记录了一个对应的空闲分区链表表头指针
  - 优点：查找速度快



##### 分区的分配与回收

分配：设请求的分区大小为`u.size`，表中每个空闲分区大小为`u.size`，若`m.size-u.size≤size(不再切割的剩余分区的大小)`，则认为多余部分太小，不可切割。否则（即可以分配的情况下），从该分区按照请求大小**划分一块内存空间并分配出去**，**余下的部分仍留在空闲分区链表中**。



回收：当进程运行完毕而需释放内存时，系统根据回收区的起始地址，从空闲分区链表中找到相应的插入点进行分配。**图中F1、F2为空闲分区**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102222842206.png" alt="image-20240102222842206" style="zoom:50%;" />

四种情况：

- 修改F1大小，分区大小为两者之和
- 将回收区起始地址作为新空闲区的起始地址，分区大小为两者之和
- 使用F1的表项和起始地址，取消F2的表项，分区大小为三者之和
- 单独建立一个新表项，填写回收区的起始地址和大小



#### 4. 动态重定位分区分配

**紧凑**：通过移动内存中的作业位置，以把原来多个分散的小分区拼接成一个大分区的方法

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102224256502.png" alt="image-20240102224256502" style="zoom:60%;" />

**动态重定位**：为使地址的转换不会影响到指令的执行速度，必须有**硬件地址变换机构**的支持，即须在系统中增设一个**重定位寄存器**，用它来存放程序（数据）在**内存中的起始地址**

程序在执行时，真正访问的内存地址是**相对地址**与**重定位寄存器中的地址**相加而形成的

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102224457665.png" alt="image-20240102224457665" style="zoom:67%;" />



### 5.5 分页式存储管理方式

连续分配方式会有产生很多“碎片”，虽然可以用紧凑方法将许多碎片拼接成可用的大块空间，但是要付出很大的开销。

如果允许一个进程直接分散地装入许多不相邻地分区中，就可充分利用内存空间而无需再紧凑，也就是**“离散分配方式”**



#### 分页存储的基本方法

页面：将进程的地址空间分成若干个页，并为每一页加以编号，如第0页、第1页等。同样将内存空间分成若干块**（页的大小和块的大小是一样的）**。再分配内存时，以块为单位，将进程中的若干页分别装入多个**可以不相邻**的物理块中。

**页内碎片：**由于**进程的最后一页经常装不满一块**，进而形成了不可利用的碎片，称为“页内碎片” 



**地址结构（要考计算）：**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102231130466.png" alt="image-20240102231130466" style="zoom:50%;" />

- 页号
  - 12-31位：20位
  - 地址空间最多允许有1M（2^20）页
- 位移量W（业内地址）
  - 0-11位：12位
  - 每页地址大小为4KB（2^12）

对某特定机器，其地址结构是一定的。若给定一个**逻辑地址空间中的地址为A**，**页面的大小为L**，则**页号P**和**页内地址d**可按下式求得:
$$
P=INT[\frac{A}{L}] \\
d=[A]\%L
$$
其中**INT为取整函数**

例如：系统页面大小为1KB（1024），设A=5168B，则P=5，d=48



**页表：**

逻辑地址空间内的所有页，依次在页表中有一表项，记录相应页在内存中对应的物理块号

**作用：实现从页号到块号的地址映射。** 

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102232527387.png" alt="image-20240102232527387" style="zoom:60%;" />

#### 地址变换机构 （重要）

将用户地址空间中的**逻辑地址**变换为内存空间中的**物理地址**

借助页表实现的，在系统中只设置一个**页表寄存器PTR**，在其中存放**页表在内存的始址和页表的长度**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102232745824.png" alt="image-20240102232745824" style="zoom:60%;" />

**地址转换方法：**
$$
物理地址=页号→块号.concat(页内地址)
$$
页表是存放在内存中的，这使得CPU每次存取一个数据都要访问内存两次。为了加快速度，在**CPU内部的高速缓存**（Cache）中增加一个地址变换高速缓存**（TLB，快表）**



#### 两级页表

针对难于找到大的连续的内存空间来存放页表的问题，可利用**将页表进行分页的方法**，使每个页面的大小与内存物理块的大小相同，然后离散地将各个页面分别存放在不同的物理块中。

同样，也要为离散分配的页表再建立一张页表，称为**外层页表**(Outer Page Table)，在每个页表项中记录了**页表页面的物理块号**。

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102233347289.png" alt="image-20240102233347289" style="zoom:60%;" />

32位逻辑地址空间为例，页面大小为4KB（12位）

- **若采用一级页表结构：**
  - 应具有20位的页号（32-12=20），即页表项应有1M个
- **若采用两级页表结构：**（记得看作业题理解）
  - 再对页表进行分页，使每页中包含2^10（即1024）个页表项，最多允许有2的10次方个页表分页
  - 外层页表中的外层页内地址P2为10位，外层页号P1也为10位



### 5.6 分段式存储管理方式

引入分段存储管理方式的目的：主要是为了，满足用户（程序员）在编程和使用上多方面的要求，其中有些要求是其他几种存储管理方式所难以满足的。

#### 分段系统的基本原理

**分段**：在分段存储管理方式中，作业的地址空间被划分为若干个段，**每个段定义了一组逻辑信息**

段的长度由相应的逻辑信息组的长度决定，因此**各段长度不等**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102234936790.png" alt="image-20240102234936790" style="zoom:69%;" />

**段表**：在分段式存储管理系统中，则是为每个分段分配一个连续的分区。进程中的各个段，可以离散地装入内存中不同的分区中。

类似于分页系统，在系统中为每个进程建立一张段**映射表（段表）**，用于实现从逻辑段到物理内存区的映射

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240102235028164.png" alt="image-20240102235028164" style="zoom:60%;" />

上面的阴影部分就是分段式存储管理中的**外部碎片**（思考外部碎片和内部碎片的区别）

**地址变换机构**：

系统中设置了**段表寄存器**，用于存放段表始址和段表长度TL

在地址变换时，判断是否越界：

- 逻辑地址中的**段号S与段表长度TL**比较，若S>TL，表示段号太大，是访问越界
- **段内地址d**与**该段的段长SL**比较，若超过，即d>SL，同样发出越界中断信号



**分页和分段的主要区别**：

- 页是信息的物理单位
- 页的大小固定且由系统决定
- 分页的用户程序地址空间是一维的
  - 分页完全是系统的行为，用户地址属于单一的线性地址空间
  - 分段系统中，用户程序的地址空间是二维的，需要给出段名和段内地址



### 5.7 段页式存储管理

**基本原理**：段页式系统的基本原理是分段和分页原理的结合，即先将**用户程序分成若干个段**，再把**每个段分成若干个页**，并为每一个段赋予一个段名

优点：既有分段系统的便于实现、可共享、易于保护、可动态链接；又能像分页系统，很好地解决内存的外部碎片问题



<div STYLE="page-break-after: always;"></div>

## 第六章 虚拟存储器

### 6.1 虚拟存储器概述

**局部性原理**：程序在执行时将呈现出局部性规律，即在一较短的时间内，程序的**执行仅局限于某个部分**，相应地，它所访问的存储空间也局限于某个区域

局限性又表现在下述两个方面：

- **时间局限性**：一条指令被执行了，则在不久的将来它可能再被执行 （循环）
-  **空间局限性**： 若某一存储单元被使用，则在一定时间内，与该存储单元相邻的单元可能被使用 （顺序执行）



**虚拟存储器的特征**：

- **多次性**：是指一个作业中的程序和数据，无需在作业运行时一次性地全部调入内存，而是允许被分为多次调入内存运行
- **对换性**：是指一个作业中的程序和数据无需在作业运行时一直常驻内存，而允许它们在作业运行时进行换入换出
- **虚拟性**：从逻辑上扩大内存容量，使用户所看到的内存远大于实际内存容量



### 6.2 请求分页存储管理方式

在基本分页基础上，为了能支持虚拟存储器功能，其增加了请求调页功能和页面置换功能。

#### 请求分页中的硬件支持

**请求页表机制**：其基本作用仍然是将用户地址空间中的逻辑地址映射为内存空间中的物理地址。

为了满足页面换进换出的需要，在请求页表中又增加了**四个字段**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240103102205950.png" alt="image-20240103102205950" style="zoom:67%;" />

- **状态位P**：指示该页是否在内存
- **访问字段A**：记录该页在一段时间内被访问的次数
- **修改位M**：也称脏位，标志该页是否被修改过
- **外存地址**：指示该页在外存中的地址（物理块号），供调入该页时参考

**缺页中断机构**：在请求分页系统中，每当所要访问的页面不在内存中时，便会产生一个缺页中断，请求OS将所缺之页调入内存

**地址变换机构**：用于将逻辑地址转换为物理地址

- 首先会检索**快表**，若能找到，则修改页表项的**访问位**（访问次数）；对于写指令，还要将**修改位**置成“1”；最后利用给出的物理块号和页内地址形成物理地址
- 如果快表中找不到该页的页表项，则应到内存区查找**页表**，再通过**状态位P**来了解该页**是否已调入内存**。若**已调入内存**，则将该页页表项**写入快表**（若满则对快表进行置换）；若该页**未调入内存**，则产生**缺页中断**，请求OS从**外存**把该页调入内存



#### 请求分页中的内存分配

**最小物理块数**：保证进程正常运行所需的最小物理块数

**内存分配策略**：

- **固定分配局部置换**：
  - 固定：为每个进程分配一组**数量固定**的物理块
  - 局部：发生缺页时只能从分配给进程的n个页面中选出一页置换
- **可变分配全局置换**：
  - 可变：为进程分配的物理块数量是可变的
  - 全局：发生缺页时，将OS保留的空闲物理块取出一块分给该进程
- **可变局部分配置换**：
  - 可变：为进程分配的物理块数量是可变的
  - 局部：发生缺页时只能从分配给进程的n个页面中选出一页置换
  - 如果频繁发生缺页中断，则给这个进程分配若干附加的物理块



**物理块分配算法**：

- 平均分配算法：将系统中所有可供分配的物理块平均分配给各个进程

- 比例分配算法：进程的大小（页面数量）按比例分配物理块

  - $$
    b_i=\frac{S_i}{S} \times m
    $$

  - bi是分配的物理块数（取整，大于最小物理块数），Si是进程i的页面数量，S是总页面数量，m是物理块总数

- 考虑优先权的分配算法



**缺页率计算：**（重要）
$$
f=\frac{F}{F+S}
$$
F是页面访问失败次数，S是页面访问成功次数



### 6.3 页面置换算法

#### 1. 最佳置换算法

其所选择的被淘汰页面将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面

该算法是**无法实现**的，但可以利用该算法去**评价其它算法**



#### 2. 先进先出页面置换算法 FIFO

FIFO算法是最早出现的置换算法。

该算法总是**淘汰最先进入内存的页面**，即选择在**内存中驻留时间最久**的页面予以淘汰



#### 3. 最近最久未使用页面置换算法 LRU

LRU算法是选择最近最久未使用的页面予以淘汰。

该算法为每个页面赋予一个访问字段，用来记录一个页面自上次被访问以来所经历的**时间t**。当需要淘汰一个页面时，选择现有页面中t值最大的页面进行淘汰



#### 4. 最少使用页面置换算法 LFU

采用移位寄存器的方式，每次访问某页面时，便将该移位**寄存器的最高位置1**，再**每隔一定时间（如100ms）右移一次**。这样，最少使用的页面将是Ri的和最小的页面。



#### 5. Clock置换算法

LRU的近似算法，又称最近未用(NRU)或二次机会页面置换算法

##### 简单的Clock置换算法

当利用简单Clock算法时，只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一 个循环队列。

- 每个页都与一个访问位相关联，初始值为0
- 当页被访问时置访问位为1
- 置换时选择访问位为0的页 ；若为1，重新置为0，再按照FIFO检查下一个页面

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240103112526909.png" alt="image-20240103112526909" style="zoom:50%;" />

##### 改进型Clock页面置换算法

增加一个**修改位M**。由访问位A和修改位M组成下面四种类型页面：

- 第一类 A=0，M=0：未访问且未修改 最佳
- 第二类 A=0，M=1：最近未访问但是被修改
- 第三类 A=1，M=0：最近被访问但是没被修改 可能再次被访问
- 第四类 A=1，M=1：被访问且被修改，有可能再次被访问



### 6.4 抖动和工作集

发生“抖动”的根本原因是：

- 系统中运行的进程太多，由此**分配给每一个进程的物理块太少**
- 每个进程在运行时，**频繁地出现缺页**，必须请求系统将所缺之页调入内存
- 造成每个进程的**大部分时间**都用于页面的换进/换出，而几乎不**能再去做任何有效的工作**
- 从而导致发生**处理机的利用率急剧下降并趋于0**的情况

**抖动的发生与系统为进程分配物理块的多少有关**

预防抖动的方法：（重要）

- **采用局部置换策略**：发生缺页时，只能在自己的内存空间进行置换，不允许去别的进程的内存空间获取新的物理块。即使发生抖动也不会影响别的进程
- **把工作集算法融入处理机调度中**
- **利用”L=S“准则调节缺页率**
- **选择暂停的进程**



### 6.5 请求分段存储管理方式

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20240103113817508.png" alt="image-20240103113817508" style="zoom:67%;" />

新增了**存取方式位**和**增补位**：

- **存取方式位**：表示段存取属性为只执行、只读或允许读/写
- **增补位**：表示该段在允许过程中是否做过动态增长



<div STYLE="page-break-after: always;"></div>

## 第七章 输入输出系统

### 7.1 IO系统的功能、模型与接口

#### IO系统的层次结构和模型

I/O系统管理的主要对象：I/O设备和对应的设备控制器

基本功能：能够隐藏物理设备的细节；能够对I/O设备进行控制；能够保证OS与设备无关；能够确保对设备的正确共享；能够提高处理机和I/O设备的利用率；能够处理错误

层级结构：

设备独立性软件又称与设备无关的I/O软件

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228101806433.png" alt="image-20231228101806433" style="zoom: 45%;" />

**层次视图：**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228101943048.png" alt="image-20231228101943048" style="zoom: 40%;" />



#### IO系统的接口

主要有三类：

- **块设备接口**：该接口反映了大部分**磁盘存储器**和**光盘存储器**的本质特征，用于控制该类设备的输入输出
  - 块设备：数据的存取和传输都是以数据块为单位的设备，如磁盘、光盘，通常采用DMA I/O方式
  - 隐藏了磁盘的二维结构
  - 将抽象命令映射为低层操作：如收到读磁盘命令时，先将抽象命令中的逻辑块号转换为磁盘的盘面、磁道和扇区等
- **流设备（字符设备）接口**：它反映了大部分**字符设备**的本质特征，用于控制字符设备的输入或输出
  - 字符设备：数据的存取和传输都是以字符为单位的设备，如键盘、打印机。**不可寻址**。通常采用中断驱动I/O方式
  - get和put操作：字符设备采用顺序存取方式。get操作用于从字符缓冲区取得一个字符（到内存），并将它返回给调用者。put操作用于将一个新字符（从内存）输出到字符缓冲区网络
  - in-control指令：包含许多参数，每个参数均表示一个与具体设备相关的特定功能
- **网络通信接口**



### 7.2 IO设备和设备控制器

设备控制器：控制一个或多个IO设备，以实现IO设备和计算机之间的数据交换，使CPU能从繁杂的设备控制事务中解脱出来。



IO通道：虽然在CPU与I/O设备之间增加了设备控制器后，已能大大减少CPU对I/O的干预，但当主机所配置的外设很多时，CPU的负担仍然很重。为此，**在CPU和设备控制器之间又增设了I/O通道**。

特点：

- 数据的传送独立于CPU
- 对IO操作的组织、管理及其结束处理尽量独立
- 仅当通道完成了规定的IO任务，才向CPU发出中断信号
- 与CPU共享系统内存（自己没有内存）



#### IO设备的控制方式

主要分为四种：

- **使用轮询**
  - CPU发送一条IO指令，并把状态寄存器忙闲标志busy置为1，然后不断循环测试busy，直到busy=0
- **使用中断**
  - CPU发送一条IO指令，并立刻返回执行原来的任务。当数据进入数据寄存器后，设备控制器通过控制线向CPU发送一条中断信号。若输入过程没有出错，则将数据写入内存
  - 以字（节）为单位
- **直接存储器访问（DMA）方式（重要）**
  - 数据的传输基本单位是**数据块**
  - 所传送的数据是从IO设备**直接送入内存的，或者相反**
  - 仅在传送**开始或结束时，才需要CPU干预**，整块数据的传输是在DMA控制器的控制下完成的
  - 一条指令只能去读写一个连续的数据块
- **I/O通道方式**
  - DMA方式的发展，将对一个数据块以读写为单位的干预，减少为**对一组数据块**以读写为单位的干预
  - 实现CPU、通道和IO设备三者并行操作，提高资源利用率



### 7.3 中断和中断处理程序

#### 中断的概念（重要）

中断和陷入：（区分方式为信号来源的不同）

- **中断(Interrupt)**是指CPU对I/O设备发来的中断信号的一种响应。CPU暂停正在执行的程序，保护CPU现场环境后，自动转去执行该IO设备的中断处理程序。中断是由外部设备引起的
- **陷入(Trap)**是指CPU内部事件所引起的中断，例如发生了地址越界、指令非法、电源故障等。陷入是由内部设备引起的



#### 中断处理流程（重要）

中断处理程序的处理过程看可以分为以下五步：

- **测定是否有未响应的中断信号**：程序每当执行完当前指令后，CPU都要测试是否有未响应的中断信号。如果没有则执行下一条，如果有，则停止原有进程的执行，转去执行中断处理程序
- **保护被中断进程的CPU现场环境**：在把控制权交给中断处理程序之前，需要先保护被中断进程的CPU现场环境，以便以后能回复运行
- **转入相应设备的中断处理程序**：CPU向各个中断信号源进行测试，确定引起中断的设备。确认后，设备取消发出的中断请求信号，将其中断处理程序的入口转入程序计数器。这样，CPU运行时便可自动转入。
- **处理中断**：对不同设备有不同的中断处理程序
- **恢复CPU现场环境后退出中断**





### 7.4 设备驱动程序

设备驱动程序的功能：（两到三条，简答题or选择题）

- **接收**由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列
- **检查**用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式
- **发出I/O命令**，如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待
- 及时**响应**由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理



### 7.5 与设备无关的IO软件

含义：应用程序中所用的设备不局限于使用某个具体的物理设备



### 7.6 用户层的IO软件

#### 系统调用与库函数

概念与差异：（重要）

- **系统调用**：系统调用是通向操作系统本身的接口，**是面向底层硬件的**。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。
- **库函数**：库函数（Library function）是把函数放到库里，**是面向应用开发的**。方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。
- 库函数是语言或**应用程序的一部分**；而系统调用是内核提供给应用程序的接口，属于**系统的一部分**
- 库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间
- 库函数开销较小，系统调用开销较大



#### 假脱机（SPOOLing）系统（重要）

**概念：**该技术是利用专门的**外围控制机**，先将低速I/O设备上的数据传送到高速磁盘上，或者相反。

这样当CPU需要输入数据的时候就能直接从磁盘读取数据，反之CPU输出数据的时候也能很快地先输出到磁盘上。

利用虚拟技术（例如假脱机技术），将一台物理设备变换成若干台逻辑设备，从而实现多个用户对物理设备的同时共享。

假脱机技术有输入井和输出井、输入缓冲区和输出缓冲区、输入进程和输出进程、请求打印队列组成：

- **输入输出井**：在**磁盘上**开辟的两大存储区
- 输入缓冲区和输出缓冲区：在**主存中**开辟的两个缓冲区



##### 假脱机打印机系统

打印机是经常用到的输出设备，属于**独占设备**。利用假脱机技术可以将它改造为一台可供多个用户**共享的打印设备**，从而提高设备的利用率。

假脱机打印机系统包含以下三大部分：

- **磁盘缓冲区**：在磁盘中开辟一个存储空间专门用于暂存用户程序的输出数据
- **打印缓冲区**：用于缓和CPU和磁盘之间速度不匹配的矛盾，设置在内存中，用于暂存从磁盘缓冲区发送来的数据，以后会再传送给打印设备进行打印
- **假脱机管理进程和假脱机打印进程**：由假脱机管理进程为每个要求打印的用户数据**建立一个假脱机文件**，并把它放入假脱机文件队列中，由假脱机打印进程依次对队列中的文件进行打印



##### 守护进程

取消原来的假脱机管理进程，而是为打印机建立一个守护进程。**守护进程时允许使用打印机的唯一进程**。



### 7.7 缓冲区管理

#### 为什么要有缓冲区？

- **处理速度差异**：不同设备之间的处理速度存在差异，缓冲区可以协调这些速度差异，避免数据处理的瓶颈
- **减少CPU中断频率**：缓冲区可以减少CPU对输入/输出（I/O）操作的直接干预
- **提高CPU和IO设备之间的并行性**：引入缓冲区后CPU和IO设备可并行地工作，而IO设备对CPU中断频率的降低，则可提高其并行度
- **支持数据同步和异步操作**：缓冲区支持数据的同步和异步操作。在异步操作中，应用程序可以继续执行其他任务，而数据传输在后台进行，这样可以提高程序的整体效率



### 7.8 磁盘性能概述和磁盘调度（重要）

磁盘设备可包括一个或多个物理盘片，每个磁盘片分一个或两个存储面(Surface)

每个盘面上有若干个磁道(Track)，磁道之间留有必要的间隙(Gap)。

每条磁道又被从逻辑上划分为若干个扇区(Sectors)。**一个扇区称为一个盘块（或数据块）**，各扇区之间保留一定的间隙（Gap）

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228152403236.png" alt="image-20231228152403236" style="zoom:60%;" />



#### 磁盘的访问时间

磁盘的访问时间可以分为以下三部分：

- **寻道时间**：将磁头移动到指定磁道上所经历的时间
  - `Ts=m×n+k`
  - m是一个常数，n是磁头移动n条磁道所花费的时间之和，k是启动磁臂的时间
- **平均旋转延迟时间**：指某扇区移动到磁头下面所经历的时间
  - `Tt=1/(2r)`
  - r是磁盘每秒的转数
- **传输时间**：从磁盘读写数据所经历的时间
  - `Tt=b/(rN)`
  - b是字节数，N是一条磁道上的字节数
  - 当一次读写的字节数相当于半条磁道上的字节数时，平均旋转延迟时间和传输时间相同

总的访问时间可以用下式表示：
$$
T_a=T_s+\frac{1}{2r}+\frac{b}{rN}
$$
<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228163757175.png" alt="image-20231228163757175" style="zoom: 67%;" />



#### 磁盘调度算法（重要）

##### 1. FCFS先来先服务调度算法

这是最简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228154641763.png" alt="image-20231228154641763" style="zoom:60%;" />



##### 2. 最短寻道时间优先 SSTF

其要求访问的**磁道**与**当前磁头**所在的磁道**距离最近**，以使每次的寻道时间最短，但这种算法不能保证平均寻道时间最短

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228154754148.png" alt="image-20231228154754148" style="zoom:67%;" />

SSTF寻道性能好，但可能导致某个进程发生“饥饿”现象。因为只要不断有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I/O请求必然优先满足。



##### 3. SCAN调度算法

也称：电梯调度算法

不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是**磁头当前的移动方向**

磁臂从磁盘的一端向另一段移动，沿途响应服务请求。当到达另一端时**（边界0）**，磁头改变移动方向，继续处理。磁头在磁盘上来回扫描。**（沿着一个方向到边界，然后再转头）**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228155212977.png" alt="image-20231228155212977" style="zoom:60%;" />



##### 4. CSCAN调度算法

CSCAN算法提供比SCAN算法更为均匀的等待时间。

磁头从磁盘一段移到另一端，随着移动不断的处理请求。不过，**当磁头移到另一端时，马上返回到磁盘开始**，返回时并不处理请求。**（沿着一个方向到边界，然后直接转到最小的欲访问磁道）**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228155628114.png" alt="image-20231228155628114" style="zoom:67%;" />

CLOOK：C-SCAN的一种形式

磁头只移动到一个方向上最远的请求为止。**接着，它马上回头，而不是继续到磁盘的尽头**。

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228160055137.png" alt="image-20231228160055137" style="zoom:60%;" />



##### 5. NStepSCAN调度算法

上述调度算法的问题：**“磁臂粘着”现象**：进程反复请求对某一磁道的I/O操作

核心：

- 将磁盘请求队列分为若干个**长度为N**的子队列**（注意，是长度为N，而不是分成N个子队列）**
- 按FCFS算法依次处理子队列
- 每个子队列使用SCAN算法



##### 6. FSCAN算法

是NStepSCAN的简化。

将磁盘请求分为**两个队列**：

- 由当前所有请求磁盘的进程行程的队列**（SCAN调度）**
- 在扫描期间，新的请求IO的进程队列



<div STYLE="page-break-after: always;"></div>

## 第八章 文件管理

### 8.1 文件和文件系统

文件：是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。

文件属性包括：文件类型、文件长度、文件的物理位置和文件的建立时间



### 8.2 文件的逻辑结构

按照文件是否有结构分类：

- 有结构文件
  - 定长记录：指文件中所有记录长度都是相同的
  - 变长记录：文件中各记录的长度不一定相同，例如电子病历
- 无结构文件
  - 主要是流式文件，可以看成记录型文件的特例：一个记录仅有一个字节



按文件的组织方式来分：

- **顺序文件**：指定一个字段为关键字，所有记录按关键字排序；检索时可利用有效的查找算法，折半查找法、插值查找法、跳步查找法等
- **索引文件**：按关键字建立索引。为**变长记录文件**建立一张**索引表**。
  - ![image-20231228171036265](C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228171036265.png)
- **索引顺序文件**：有效克服了变长记录文件不便于直接存取的缺点
  - 引入文件索引表：实现随机访问。增加溢出文件：记录新增、删除和修改的记录
  - 根据关键字找到记录组中的第一个记录的表项，从中获取该记录组表现得第一个记录在主文件中得位置；然后利用顺序查找法查找主文件，从中找到想要得记录
  - ![image-20231228171117009](C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231228171117009.png)
- **直接文件和哈希文件**
  - 直接文件：根据给定的关键字直接获取指定记录得物理地址。关键字本身决定了记录的物理地址
  - 哈希文件：利用**Hash函数**将**关键字**变换为**相应记录的地址**。但为了能实现文件存储空间的动态分配，通常由Hash函数所求得的并非是相应记录的地址，而是**指向某一目录表相应表目的指针**，该表目的内容指向相应记录所在的物理块



### 8.3 文件目录

**文件控制块(FCB)**：管理和控制文件的数据结构，与文件一一对应，应该包含以下信息：

- 基本信息类
  - 文件名、文件物理地址、文件逻辑结构、文件物理结构
- 存取控制信息类
  - 文件拥有者的存取权限、各类用户的存取权限
- 使用信息类
  - 文件的建立时间、文件上一次修改的时间



**索引节点**：把**文件名与文件描述信息分开**，文件描述信息用索引结点（iNode）保存，简称为i节点（UNIX）。**减少磁盘访问次数**



简单的目录结构：目录结构的组织，是设计好文件系统的重要环节，关系到文件系统的存取速度，也关系到文件的共享性和安全性（目录结构和文件都驻留在磁盘上。）



目前广泛采用的目录结构：**多级树形目录结构**

<img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231229113339418.png" alt="image-20231229113339418" style="zoom:50%;" />



### 8.4 文件共享

文件共享有哪两种方式实现？

- 基于有向无环图
- 利用符号链接



访问矩阵的概念：用一个矩阵描述系统的访问控制





<div STYLE="page-break-after: always;"></div>

## 第九章 磁盘存储器管理

### 9.1 外存的组织方式 （重要）

不同的外存组织方式，将形成不同的文件物理结构：

- **连续组织方式**：形成的文件物理结构是顺序式文件结构
  - 优点：访问容易、访问速度快
  - 缺点：要求为一个文件分配**连续**的存储空间、必须事先知道文件的长度
  - <img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231229112835163.png" alt="image-20231229112835163" style="zoom: 50%;" />
- **链接组织方式**：形成的文件物理结构是链接式文件结构
  - 每个目录项都含有指向链接文件**第一个盘块**和**最后一个盘块的指针**
  - **隐式链接**：指针存放在每个盘块中，只适合于顺序访问
    **显式链接**：指针显式地存放在内存的**文件分配表FAT**（内存中，整个磁盘仅有一张表）中
  - 优点：消除了磁盘的外碎片、插入删除等操作变得容易、文件可动态增长
  - 缺点：只适用于顺序访问，对随机访问来说效率是很低的
  - <img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231229113125220.png" alt="image-20231229113125220" style="zoom:43%;" />
  - <img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231229113613880.png" alt="image-20231229113613880" style="zoom: 45%;" />
- **索引组织方式**：形成的文件物理结构是索引式文件结构
  - 把所有的磁盘块号放在一个索引块(表)中
  - 优点：支持随机访问，动态存取没有外碎片
  - 缺点：需要索引表，对小文件其索引块利用率低
  - <img src="C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231229113910665.png" alt="image-20231229113910665" style="zoom:50%;" />



#### FAT文件系统

FAT（File Allocation Table）文件系统是微软最早在MS-DOS开始使用的文件系统

##### **1. 以盘块为单位的FAT文件系统**

FAT12（12的意思是12位）以盘块为基本分配单位，每个分区有两张相同的FAT表，FAT1和FAT2

计算：

例如，对**1.2MB**的软盘，每个盘块大小为**512B**

- FAT共有2.4K个表项**（1.2MB/512B）**
- 每个FAT表项占12b**（1.5B，FAT12的12）**
- 因此FAT表占用3.6KB**（2.4K*1.5B）**

反过来算最大磁盘容量也要会算 P284

四分区的磁盘最大容量为**8MB**



##### **2. 以簇为单位的FAT文件系统**

簇是一组相邻的扇区，在FAT中被视作一个虚拟扇区

簇的大小一般是2n个盘块(n=1,2,4,8,…)，一个簇应包含扇区的数量与磁盘容量大小直接相关

**FAT16**支持一个簇有64个盘块，其FAT表的表项数最大为2\^16，Ø则最大可以管理的分区空间为2048MB(512\*4\*2\^16)

优点：可以减少FAT中的项数，使FAT占用更少的存储空间，并且可以减少访问FAT的存取开销

缺点：簇的容量越大，簇内碎片越大

**FAT32**管理的单个最大磁盘空间：512B*2\^32=**2TB**



### 9.2 文件存储空间的管理

为了分配盘块，就必须知道磁盘上哪些盘块是可用于分类的。设置一个磁盘分配表，用于记住可供分配的存储空间情况。



#### 位示图法

利用二进制的一位来表示磁盘中一个盘块的使用情况。

- 当值为0时，表示对应的盘块空闲
- 当值为1时，表示已分配

磁盘上的**所有盘块**都有一个**二进制位与之对应**，这样，由所有盘块所对应的位构成一个集合，称为位示图

![image-20231229115819459](C:\Users\Jerry\AppData\Roaming\Typora\typora-user-images\image-20231229115819459.png)

盘块的分配：

- 顺序扫描位示图，从中找出一个或一组其值为0的二进制位
- 将所找到的一个或一组二进制位，转换成与之相应的盘块号。假定找到的其值为0的二进制位，位于位示图的**第i行、第j列**，则其相应的盘块号为：`b=n×(i-1)+j`，**n表示每行的位数**
- 修改位视图，令map[i, j]=1 **（注意它是从1开始编号）**

盘块的回收：

- 将盘块号转换为行号列号：
  `i=(b-1)/n+1  ` `j=(b-1)%n+1` **（注意b-1）**
- 修改位视图，令map[i, j]=0 



——JerryKim